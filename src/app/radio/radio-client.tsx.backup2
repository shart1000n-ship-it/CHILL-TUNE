'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { useSession, signIn, signOut } from 'next-auth/react';
import { createClient } from '@supabase/supabase-js';

// Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export default function RadioClient() {
  // Music streams - All Hip Hop & R&B
  const STREAMS = [
    { name: "PowerHitz (Pure R&B)", url: "https://stream.radiojar.com/4ywdgup3bnzuv", genre: "R&B" },
    { name: "Hip Hop Nation", url: "https://stream.radiojar.com/4ywdgup3bnzuv", genre: "Hip-Hop" },
    { name: "R&B Vibes", url: "https://stream.radiojar.com/4ywdgup3bnzuv", genre: "R&B" },
    { name: "Hip Hop Classics", url: "https://stream.radiojar.com/4ywdgup3bnzuv", genre: "Hip-Hop" }
  ];

  // MIDI Controller Support
  const [midiAccess, setMidiAccess] = useState<any>(null);
  const [midiInputs, setMidiInputs] = useState<any[]>([]);
  const [selectedMidiInput, setSelectedMidiInput] = useState<any>(null);
  const [midiConnected, setMidiConnected] = useState(false);

  // Multi-Admin Live Streaming
  const [activeStreamers, setActiveStreamers] = useState<{ id: string; email: string; type: "audio" | "video" }[]>([]);
  const [streamerStreams, setStreamerStreams] = useState<{ [key: string]: MediaStream }>({});
  const [streamerVideos, setStreamerVideos] = useState<{ [key: string]: HTMLVideoElement }>({});

  // State variables
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentStreamIndex, setCurrentStreamIndex] = useState(0);
  const [volume, setVolume] = useState(0.5);
  const [isSignedIn, setIsSignedIn] = useState(false);
  const [username, setUsername] = useState('');
  const [messages, setMessages] = useState<Array<{ id: string; username: string; message: string; timestamp: string }>>([]);
  const [newMessage, setNewMessage] = useState('');
  const [isLive, setIsLive] = useState(false);
  const [isVideoLive, setIsVideoLive] = useState(false);
  const [onAirTime, setOnAirTime] = useState(0);
  const [exclusiveFile, setExclusiveFile] = useState<File | null>(null);
  const [isExclusivePlaying, setIsExclusivePlaying] = useState(false);
  const [exclusiveDuration, setExclusiveDuration] = useState(0);
  const [exclusiveElapsed, setExclusiveElapsed] = useState(0);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [listenerCount, setListenerCount] = useState(42);
  const [crossfader, setCrossfader] = useState(0.5);
  const [micVolume, setMicVolume] = useState(0.5);
  const [streamVolume, setStreamVolume] = useState(0.5);
  const [exclusiveVolume, setExclusiveVolume] = useState(0.5);
  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);
  const [micGainNode, setMicGainNode] = useState<GainNode | null>(null);
  const [streamGainNode, setStreamGainNode] = useState<GainNode | null>(null);
  const [exclusiveGainNode, setExclusiveGainNode] = useState<GainNode | null>(null);

  // Refs
  const audioRef = useRef<HTMLAudioElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const exclusiveAudioRef = useRef<HTMLAudioElement>(null);

  // Session and admin check
  const { data: session } = useSession();
  const isAdmin = session?.user?.email === 'chillandtune.fm' || 
                  (process.env.NEXT_PUBLIC_ADMIN_EMAILS && 
                   process.env.NEXT_PUBLIC_ADMIN_EMAILS.includes(session?.user?.email || ''));

  // Radio schedule - Hip-Hop & R&B Focused
  const schedule = [
    { day: 'Monday', time: '6:00 PM - 10:00 PM', show: 'Hip Hop Classics', genre: 'Hip-Hop' },
    { day: 'Tuesday', time: '6:00 PM - 10:00 PM', show: 'R&B Vibes', genre: 'R&B' },
    { day: 'Wednesday', time: '6:00 PM - 10:00 PM', show: 'Hip Hop Nation', genre: 'Hip-Hop' },
    { day: 'Thursday', time: '6:00 PM - 10:00 PM', show: 'PowerHitz Pure R&B', genre: 'R&B' },
    { day: 'Friday', time: '6:00 PM - 12:00 AM', show: 'Weekend Mix', genre: 'Mixed' },
    { day: 'Saturday', time: '2:00 PM - 12:00 AM', show: 'Saturday Sessions', genre: 'Mixed' },
    { day: 'Sunday', time: '2:00 PM - 10:00 PM', show: 'Sunday Chill', genre: 'R&B' }
  ];

  // Initialize audio system when component mounts
  useEffect(() => {
    // Create audio context immediately
    const initAudio = async () => {
      try {
        const newAudioContext = new AudioContext();
        setAudioContext(newAudioContext);
        
        // Create gain nodes for immediate control
        const micGain = newAudioContext.createGain();
        const streamGain = newAudioContext.createGain();
        const exclusiveGain = newAudioContext.createGain();
        
        // Set initial values (using initial state values, not current state)
        micGain.gain.value = 0.5; // Initial micVolume
        streamGain.gain.value = 0.5; // Initial streamVolume
        exclusiveGain.gain.value = 0.5; // Initial exclusiveVolume
        
        // Store nodes in state
        setMicGainNode(micGain);
        setStreamGainNode(streamGain);
        setExclusiveGainNode(exclusiveGain);
        
        console.log('Audio system initialized successfully');
        
      } catch (error) {
        console.error('Failed to initialize audio:', error);
      }
    };
    
    initAudio();
  }, []); // Run once on mount

  // Connect audio nodes to actual audio sources
  useEffect(() => {
    if (!audioContext || !streamGainNode || !exclusiveGainNode) return;

    // Connect the main audio player to the stream gain node
    if (audioRef.current) {
      try {
        // Create a media element source from the audio element
        const audioSource = audioContext.createMediaElementSource(audioRef.current);
        
        // Connect: audio source -> stream gain -> destination
        audioSource.connect(streamGainNode);
        streamGainNode.connect(audioContext.destination);
        
        console.log('Audio player connected to stream gain node');
        
        // Apply initial crossfader effect
        const streamGainValue = (1 - crossfader) * streamVolume * volume;
        streamGainNode.gain.setValueAtTime(streamGainValue, audioContext.currentTime);
        
      } catch (error) {
        console.error('Failed to connect audio:', error);
      }
    }
  }, [audioContext, streamGainNode, exclusiveGainNode]);

  // Initialize audio player and crossfader
  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.volume = volume;
    }
  }, [volume]);

  // Real-time audio control effects
  useEffect(() => {
    // Update mic volume in real-time
    if (micGainNode && audioContext) {
      micGainNode.gain.setValueAtTime(micVolume, audioContext.currentTime);
      console.log('Mic volume updated:', micVolume);
    }
  }, [micVolume, micGainNode, audioContext]);

  // Crossfader effect on exclusive tracks - Fixed functionality
  useEffect(() => {
    // Update exclusive track volume if it's currently playing
    if (exclusiveGainNode && audioContext) {
      const newGainValue = crossfader * exclusiveVolume;
      exclusiveGainNode.gain.setValueAtTime(newGainValue, audioContext.currentTime);
      console.log('Exclusive gain updated:', newGainValue);
    }
    
    // Update stream volume if we have stream gain node
    if (streamGainNode && audioContext) {
      const newStreamGainValue = (1 - crossfader) * streamVolume;
      streamGainNode.gain.setValueAtTime(newStreamGainValue, audioContext.currentTime);
      console.log('Stream gain updated:', newStreamGainValue);
    }
  }, [crossfader, streamVolume, exclusiveVolume, exclusiveGainNode, streamGainNode, audioContext]);

  // Moving timestamp for exclusive tracks
  useEffect(() => {
    let interval: any;
    if (isExclusivePlaying && exclusiveDuration > 0) {
      interval = setInterval(() => {
        setExclusiveElapsed(prev => {
          if (prev >= exclusiveDuration) {
            setIsExclusivePlaying(false);
            return 0;
          }
          return prev + 1;
        });
      }, 100); // Update every 100ms for smooth movement
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isExclusivePlaying, exclusiveDuration]);

  // Stream cycling effect
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentStreamIndex(prev => (prev + 1) % STREAMS.length);
    }, 30000);

    return () => clearInterval(interval);
  }, []);

  // On-air time tracker
  useEffect(() => {
    let interval: any;
    if (isLive) {
      interval = setInterval(() => {
        setOnAirTime(prev => prev + 1);
      }, 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isLive]);

  // Exclusive track duration
  useEffect(() => {
    let interval: any;
    if (isExclusivePlaying && exclusiveDuration > 0) {
      interval = setInterval(() => {
        setExclusiveElapsed(prev => {
          if (prev >= exclusiveDuration) {
            setIsExclusivePlaying(false);
            return 0;
          }
          return prev + 1;
        });
      }, 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isExclusivePlaying, exclusiveDuration]);

  // Recording time tracker
  useEffect(() => {
    let interval: any;
    if (isRecording) {
      interval = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isRecording]);

  // Simulate listener count
  useEffect(() => {
    const interval = setInterval(() => {
      setListenerCount(prev => {
        if (isLive) {
          return Math.max(prev, Math.floor(Math.random() * 50) + 20);
        } else {
          return Math.floor(Math.random() * 15) + 5;
        }
      });
    }, 5000);
    return () => clearInterval(interval);
  }, [isLive]);

  // Chat functionality
  useEffect(() => {
    if (process.env.NEXT_PUBLIC_DISABLE_SOCKET_IO === 'true') {
      const channel = supabase.channel('chat');
      
      channel.on('postgres_changes', { event: '*', schema: 'public', table: 'messages' }, (payload: any) => {
        if (payload.new) {
          const newMessage = {
            id: payload.new.id || Date.now().toString(),
            username: payload.new.username || 'Anonymous',
            message: payload.new.message || '',
            timestamp: payload.new.timestamp || new Date().toLocaleTimeString()
          };
          setMessages(prev => [...prev, newMessage]);
        }
      });

      channel.subscribe();
    }
  }, []);

  const sendMessage = async () => {
    if (!newMessage.trim() || !username.trim()) return;

    const message = {
      id: Date.now().toString(),
      username,
      message: newMessage,
      timestamp: new Date().toLocaleTimeString()
    };

    setMessages(prev => [...prev, message]);
    setNewMessage('');

    try {
      await supabase.from('messages').insert([message]);
    } catch (error) {
      console.log('Message saved locally');
    }
  };

  const handlePlayPause = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    
    // Apply to audio element
    if (audioRef.current) {
      audioRef.current.volume = newVolume;
    }
    
    // Also apply to stream gain node if available
    if (streamGainNode && audioContext) {
      const streamGainValue = newVolume * (1 - crossfader) * streamVolume;
      streamGainNode.gain.setValueAtTime(streamGainValue, audioContext.currentTime);
      console.log('Main volume changed to:', newVolume, 'Stream gain:', streamGainValue);
    }
  };

  const handleMicVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setMicVolume(newVolume);
    
    // Apply to mic gain node immediately
    if (micGainNode && audioContext) {
      micGainNode.gain.setValueAtTime(newVolume, audioContext.currentTime);
      console.log('Mic volume changed to:', newVolume);
    }
  };

  const handleCrossfaderChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newCrossfader = parseFloat(e.target.value);
    setCrossfader(newCrossfader);
    
    // Apply crossfader effect immediately to both gain nodes
    if (streamGainNode && exclusiveGainNode && audioContext) {
      const streamGainValue = (1 - newCrossfader) * streamVolume * volume;
      const exclusiveGainValue = newCrossfader * exclusiveVolume;
      
      streamGainNode.gain.setValueAtTime(streamGainValue, audioContext.currentTime);
      exclusiveGainNode.gain.setValueAtTime(exclusiveGainValue, audioContext.currentTime);
      
      console.log('Crossfader changed to:', newCrossfader, 'Stream:', streamGainValue, 'Exclusive:', exclusiveGainValue);
    }
  };

  const handleStreamVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setStreamVolume(newVolume);
    
    // Apply to stream gain node immediately
    if (streamGainNode && audioContext) {
      const streamGainValue = (1 - crossfader) * newVolume * volume;
      streamGainNode.gain.setValueAtTime(streamGainValue, audioContext.currentTime);
      console.log('Stream volume changed to:', newVolume, 'Gain:', streamGainValue);
    }
  };

  const handleExclusiveVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setExclusiveVolume(newVolume);
    
    // Apply to exclusive gain node immediately
    if (exclusiveGainNode && audioContext) {
      const exclusiveGainValue = crossfader * newVolume;
      exclusiveGainNode.gain.setValueAtTime(exclusiveGainValue, audioContext.currentTime);
      console.log('Exclusive volume changed to:', newVolume, 'Gain:', exclusiveGainValue);
    }
  };



  const enableMIDI = async () => {
    try {
      if (navigator.requestMIDIAccess) {
        const midiAccess = await navigator.requestMIDIAccess();
        midiAccess.onstatechange = (event) => {
          console.log('MIDI state changed:', event);
        };
        
        midiAccess.inputs.forEach((input) => {
          input.onmidimessage = (event) => {
            if (event.data && event.data[0] === 176) {
              if (event.data[1] === 7) {
                setVolume(event.data[2] / 127);
              } else if (event.data[1] === 8) {
                setCrossfader(event.data[2] / 127);
              }
            }
          };
        });
      }
    } catch (error) {
      console.log('MIDI not available');
    }
  };

  const goLiveAudio = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Add current user to active streamers
      const currentUser = session?.user?.email || 'Unknown DJ';
      const streamerId = `audio-${Date.now()}`;
      setActiveStreamers(prev => [...prev, { id: streamerId, email: currentUser, type: 'audio' as const }]);
      setStreamerStreams(prev => ({ ...prev, [currentUser]: stream }));
      
      // Create and display audio indicator
      const audioIndicator = document.createElement('div');
      audioIndicator.id = 'audio-live-indicator';
      audioIndicator.innerHTML = `
        <div style="position: fixed; top: 20px; right: 20px; background: red; color: white; padding: 10px; border-radius: 5px; z-index: 1000;">
          üé§ LIVE AUDIO - ${currentUser}
        </div>
      `;
      document.body.appendChild(audioIndicator);
      
      alert(`üé§ ${currentUser} is now LIVE on Audio!`);
      console.log('Live audio started for:', currentUser);
      
    } catch (error) {
      console.error('Failed to start live audio:', error);
      alert('Failed to start live audio: ' + (error as Error).message);
    }
  };

  const goLiveVideo = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
      
      // Add current user to active streamers
      const currentUser = session?.user?.email || 'Unknown DJ';
      const streamerId = `video-${Date.now()}`;
      setActiveStreamers(prev => [...prev, { id: streamerId, email: currentUser, type: 'video' as const }]);
      setStreamerStreams(prev => ({ ...prev, [currentUser]: stream }));
      
      // Create video element for this streamer
      const videoElement = document.createElement('video');
      videoElement.autoplay = true;
      videoElement.muted = true;
      videoElement.style.width = '100%';
      videoElement.style.height = '200px';
      videoElement.style.borderRadius = '8px';
      videoElement.style.marginBottom = '10px';
      
      // Add streamer name above video
      const streamerLabel = document.createElement('div');
      streamerLabel.className = 'text-white text-sm font-semibold mb-2';
      streamerLabel.textContent = `üé• ${currentUser} - LIVE`;
      
      // Find the video live screen container
      const videoContainer = document.getElementById('video-live-screen');
      if (videoContainer) {
        videoContainer.appendChild(streamerLabel);
        videoContainer.appendChild(videoElement);
        videoElement.srcObject = stream;
        
        // Store reference
        setStreamerVideos(prev => ({ ...prev, [currentUser]: videoElement }));
      }
      
      alert(`üé• ${currentUser} is now LIVE on Video!`);
      console.log('Live video started for:', currentUser);
      
    } catch (error) {
      console.error('Failed to start live video:', error);
      alert('Failed to start live video: ' + (error as Error).message);
    }
  };

  const stopLive = () => {
    // Remove current user from active streamers
    const currentUser = session?.user?.email || 'Unknown DJ';
    setActiveStreamers(prev => prev.filter(streamer => streamer.email !== currentUser));
    
    // Stop and remove streams
    const userStream = streamerStreams[currentUser];
    if (userStream) {
      userStream.getTracks().forEach(track => track.stop());
      setStreamerStreams(prev => {
        const newStreams = { ...prev };
        delete newStreams[currentUser];
        return newStreams;
      });
    }
    
    // Remove video elements
    const userVideo = streamerVideos[currentUser];
    if (userVideo) {
      userVideo.remove();
      setStreamerVideos(prev => {
        const newVideos = { ...prev };
        delete newVideos[currentUser];
        return newVideos;
      });
    }
    
    // Remove audio indicator
    const audioIndicator = document.getElementById('audio-live-indicator');
    if (audioIndicator) {
      audioIndicator.remove();
    }
    
    alert(`üõë ${currentUser} stopped broadcasting`);
    console.log('Live broadcast stopped for:', currentUser);
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file && file.type.startsWith('audio/')) {
      setExclusiveFile(file);
    }
  };

  const startExclusiveFromFile = async () => {
    if (!exclusiveFile) return;

    try {
      if (!audioContext) {
        const newAudioContext = new AudioContext();
        setAudioContext(newAudioContext);
      }

      const currentContext = audioContext || new AudioContext();
      
      if (currentContext.state === 'suspended') {
        await currentContext.resume();
      }

      const arrayBuffer = await exclusiveFile.arrayBuffer();
      const audioBuffer = await currentContext.decodeAudioData(arrayBuffer);
      
      setExclusiveDuration(Math.floor(audioBuffer.duration));
      setExclusiveElapsed(0);
      setIsExclusivePlaying(true);


      // Create gain node for crossfader control
      const gainNode = currentContext.createGain();
      setExclusiveGainNode(gainNode);
      
      // Set initial volume based on crossfader
      gainNode.gain.value = crossfader * exclusiveVolume;
      
      const source = currentContext.createBufferSource();
      source.buffer = audioBuffer;
      
      // Simple connection: source -> gain -> destination
      source.connect(gainNode);
      gainNode.connect(currentContext.destination);
      
      // Start playback
      source.start(0);
      
      console.log('Exclusive track started:', {
        duration: audioBuffer.duration,
        crossfader: crossfader,
        exclusiveVolume: exclusiveVolume,
        gainValue: gainNode.gain.value
      });

      source.onended = () => {
        setIsExclusivePlaying(false);
        setExclusiveElapsed(0);
  
        console.log('Exclusive track ended');
      };

    } catch (error) {
      console.error('Failed to play exclusive file:', error);
      alert('Failed to play exclusive file. Please try again.');
    }
  };

  const startPodcast = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;

      const chunks: Blob[] = [];
      mediaRecorder.ondataavailable = (event) => {
        chunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `podcast-${Date.now()}.webm`;
        a.click();
        URL.revokeObjectURL(url);
      };

      mediaRecorder.start();
      setIsRecording(true);
      setRecordingTime(0);
    } catch (error) {
      console.error('Failed to start podcast:', error);
    }
  };

  const stopPodcast = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const testAudio = () => {
    try {
      if (!audioContext) {
        const newAudioContext = new AudioContext();
        setAudioContext(newAudioContext);
      }

      const currentContext = audioContext || new AudioContext();

      if (currentContext.state === 'suspended') {
        currentContext.resume();
      }

      // Create a simple test tone
      const oscillator = currentContext.createOscillator();
      const gainNode = currentContext.createGain();
      
      oscillator.frequency.setValueAtTime(440, currentContext.currentTime); // A4 note
      gainNode.gain.setValueAtTime(0.1, currentContext.currentTime);
      
      oscillator.connect(gainNode);
      gainNode.connect(currentContext.destination);
      
      oscillator.start();
      oscillator.stop(currentContext.currentTime + 1);
      
      console.log('Test audio played successfully');
      alert('Test audio played! Check console for details.');
      
    } catch (error) {
      console.error('Test audio failed:', error);
      alert('Test audio failed: ' + (error as Error).message);
    }
  };

  const testAudioChain = () => {
    try {
      if (!audioContext) {
        alert('Audio system not initialized. Please wait a moment and try again.');
        return;
      }

      // Create a test tone that goes through the entire audio chain
      const oscillator = audioContext.createOscillator();
      const testGain = audioContext.createGain();
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
      testGain.gain.setValueAtTime(0.1, audioContext.currentTime);
      
      // Connect through the audio processing chain
      oscillator.connect(testGain);
      
      if (micGainNode) {
        testGain.connect(micGainNode);
        console.log('‚úÖ Mic gain node connected');
      }
      
      if (streamGainNode && exclusiveGainNode) {
        if (micGainNode) {
          micGainNode.connect(streamGainNode);
          micGainNode.connect(exclusiveGainNode);
          console.log('‚úÖ Crossfader nodes connected');
        }
      }
      
      // Connect to destination
      if (streamGainNode) streamGainNode.connect(audioContext.destination);
      if (exclusiveGainNode) exclusiveGainNode.connect(audioContext.destination);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 2);
      
      console.log('üéµ Test audio chain playing through all controls!');
      alert('üéµ Test audio playing through mic volume, EQ, and crossfader! Check console for details.');
      
    } catch (error) {
      console.error('Test audio chain failed:', error);
      alert('Test failed: ' + (error as Error).message);
    }
  };

  const testAudioSystem = () => {
    console.log('=== Audio System Test ===');
    console.log('Audio Context:', audioContext ? 'Active' : 'None');
    console.log('Stream Gain Node:', streamGainNode ? 'Active' : 'None');
    console.log('Exclusive Gain Node:', exclusiveGainNode ? 'Active' : 'None');
    console.log('Mic Gain Node:', micGainNode ? 'Active' : 'None');
    
    if (streamGainNode && audioContext) {
      console.log('Stream Gain Value:', streamGainNode.gain.value);
      console.log('Stream Volume:', streamVolume);
      console.log('Main Volume:', volume);
      console.log('Crossfader:', crossfader);
    }
    
    if (exclusiveGainNode && audioContext) {
      console.log('Exclusive Gain Value:', exclusiveGainNode.gain.value);
      console.log('Exclusive Volume:', exclusiveVolume);
    }
    
    if (micGainNode && audioContext) {
      console.log('Mic Gain Value:', micGainNode.gain.value);
      console.log('Mic Volume:', micVolume);
    }
    
    alert('Check console for audio system details!');
  };

  const testWorkingAudio = () => {
    try {
      if (!audioContext) {
        alert('Audio system not initialized. Please wait a moment and try again.');
        return;
      }

      // Create a simple test tone that goes through the gain nodes
      const oscillator = audioContext.createOscillator();
      const testGain = audioContext.createGain();
      
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
      testGain.gain.setValueAtTime(0.1, audioContext.currentTime);
      
      // Connect through the working audio chain
      oscillator.connect(testGain);
      
      if (streamGainNode) {
        testGain.connect(streamGainNode);
        console.log('‚úÖ Test audio connected to stream gain node');
      }
      
      if (exclusiveGainNode) {
        testGain.connect(exclusiveGainNode);
        console.log('‚úÖ Test audio connected to exclusive gain node');
      }
      
      // Start and stop the test tone
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 1);
      
      console.log('üéµ Test audio playing through gain nodes!');
      alert('üéµ Test audio playing! Move the crossfader and volume controls to hear the difference!');
      
    } catch (error) {
      console.error('Test audio failed:', error);
      alert('Test failed: ' + (error as Error).message);
    }
  };

  // Initialize MIDI Controller Support
  useEffect(() => {
    const initMIDI = async () => {
      try {
        if (navigator.requestMIDIAccess) {
          const access = await navigator.requestMIDIAccess();
          setMidiAccess(access);
          
          const inputs = Array.from(access.inputs.values());
          setMidiInputs(inputs);
          
          if (inputs.length > 0) {
            setSelectedMidiInput(inputs[0]);
            connectMIDIInput(inputs[0]);
          }
          
          console.log('MIDI access granted:', inputs.length, 'inputs available');
        } else {
          console.log('MIDI not supported in this browser');
        }
      } catch (error) {
        console.error('Failed to initialize MIDI:', error);
      }
    };
    
    initMIDI();
  }, []);

  const connectMIDIInput = (input: any) => {
    if (selectedMidiInput) {
      selectedMidiInput.onmidimessage = null;
    }
    
    input.onmidimessage = (event: any) => {
      const [status, note, velocity] = event.data;
      
      // MIDI Control Change (CC) messages
      if (status === 176) { // CC on channel 1
        switch (note) {
          case 7: // Volume slider
            const volumeValue = velocity / 127;
            setVolume(volumeValue);
            handleVolumeChange({ target: { value: volumeValue.toString() } } as any);
            break;
          case 8: // Balance/Crossfader
            const crossfaderValue = velocity / 127;
            setCrossfader(crossfaderValue);
            handleCrossfaderChange({ target: { value: crossfaderValue.toString() } } as any);
            break;
          case 9: // Mic Volume
            const micValue = velocity / 127;
            setMicVolume(micValue);
            handleMicVolumeChange({ target: { value: micValue.toString() } } as any);
            break;
          case 10: // Stream Volume
            const streamValue = velocity / 127;
            setStreamVolume(streamValue);
            handleStreamVolumeChange({ target: { value: streamValue.toString() } } as any);
            break;
          case 11: // Exclusive Volume
            const exclusiveValue = velocity / 127;
            setExclusiveVolume(exclusiveValue);
            handleExclusiveVolumeChange({ target: { value: exclusiveValue.toString() } } as any);
            break;
        }
      }
      
      // MIDI Note messages for triggering actions
      if (status === 144 && velocity > 0) { // Note On
        switch (note) {
          case 36: // C2 - Go Live Audio
            goLiveAudio();
            break;
          case 37: // C#2 - Go Live Video
            goLiveVideo();
            break;
          case 38: // D2 - Stop Live
            stopLive();
            break;
          case 39: // D#2 - Play Exclusive
            if (fileInputRef.current) {
              fileInputRef.current.click();
            }
            break;
          case 40: // E2 - Start Podcast
            startPodcast();
            break;
        }
      }
    };
    
    setSelectedMidiInput(input);
    setMidiConnected(true);
    console.log('MIDI input connected:', input.name);
  };

  return (
    <div className="min-h-screen relative overflow-hidden">
      {/* Background removed - now handled by parent page component */}

      {/* Main Content */}
      <div className="relative z-10 container mx-auto px-4 py-8">
        <div className="bg-slate-800/80 backdrop-blur-sm rounded-lg p-6 shadow-lg border border-slate-600">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-2xl font-bold text-white">Now Playing</h2>
            <div className="flex items-center space-x-2">
              <span className="bg-red-600 text-white px-3 py-1 rounded-full text-sm font-semibold">Hip-Hop</span>
              <span className="bg-blue-600 text-white px-3 py-1 rounded-full text-sm font-semibold">R&B</span>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <button
              onClick={handlePlayPause}
              className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
            >
              {isPlaying ? 'Pause' : 'Play'}
            </button>
            <div className="flex-1">
              <div className="text-lg font-semibold text-white">
                {STREAMS[currentStreamIndex].name}
              </div>
              <div className="text-slate-300">
                <span className="text-blue-400 font-medium">{STREAMS[currentStreamIndex].genre}</span> ‚Ä¢ Live Stream
              </div>
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={volume}
                onChange={handleVolumeChange}
                className="w-24"
              />
              <span className="text-sm text-slate-300">{Math.round(volume * 100)}%</span>
            </div>
          </div>
          <audio
            ref={audioRef}
            src={STREAMS[currentStreamIndex].url}
            onPlay={() => setIsPlaying(true)}
            onPause={() => setIsPlaying(false)}
            onError={(e) => console.error('Audio error:', e)}
          />
        </div>

        <div className="bg-slate-800/80 backdrop-blur-sm rounded-lg p-6 shadow-lg border border-slate-600">
          <h2 className="text-2xl font-bold text-white mb-4">Live Chat</h2>
          
          {!isSignedIn ? (
            <div className="mb-4">
              <input
                type="text"
                placeholder="Enter username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                className="border border-slate-600 bg-slate-700 text-white rounded-lg px-3 py-2 mr-2 placeholder-slate-400"
              />
              <button
                onClick={() => setIsSignedIn(true)}
                className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg"
              >
                Join Chat
              </button>
            </div>
          ) : (
            <div className="mb-4">
              <span className="text-sm text-slate-300">Signed in as: {username}</span>
              <button
                onClick={() => setIsSignedIn(false)}
                className="ml-2 text-blue-400 hover:text-blue-300"
              >
                Sign Out
              </button>
            </div>
          )}
          
          <div className="h-64 overflow-y-auto border border-slate-600 rounded-lg p-3 mb-4 bg-slate-700">
            {messages.map((msg) => (
              <div key={msg.id} className="mb-2">
                <span className="font-semibold text-blue-400">{msg.username}:</span>
                <span className="ml-2 text-slate-200">{msg.message}</span>
                <span className="ml-2 text-xs text-slate-400">{msg.timestamp}</span>
              </div>
            ))}
          </div>
          
          {isSignedIn && (
            <div className="flex space-x-2">
              <input
                type="text"
                placeholder="Type your message..."
                value={newMessage}
                onChange={(e) => setNewMessage(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                className="flex-1 border border-slate-600 bg-slate-700 text-white rounded-lg px-3 py-2 placeholder-slate-400"
              />
              <button
                onClick={sendMessage}
                className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg"
              >
                Send
              </button>
            </div>
          )}
        </div>

        {/* Professional DJ Console with Video Live Screen */}
        <div className="bg-gradient-to-r from-gray-900 to-gray-800 rounded-lg p-6 shadow-2xl border border-gray-700">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-3xl font-bold text-white">üéõÔ∏è Professional DJ Console</h2>
            <div className="text-right">
              <div className="text-sm text-gray-300">Listeners</div>
              <div className="text-2xl font-bold text-green-400">{listenerCount}</div>
            </div>
          </div>
          
          {!session ? (
            <div className="text-center py-8">
              <button
                onClick={() => signIn()}
                className="bg-gradient-to-r from-blue-600 to-slate-600 hover:from-blue-700 hover:to-slate-700 text-white px-8 py-4 rounded-lg font-semibold text-lg transition-all transform hover:scale-105"
              >
                üîê Sign In to Access DJ Console
              </button>
            </div>
          ) : (
            <div className="space-y-6">
              <div className="flex items-center justify-between bg-gray-800 rounded-lg p-4">
                <span className="text-gray-300">Signed in as: <span className="text-white font-semibold">{session.user?.email}</span></span>
                <button
                  onClick={() => signOut()}
                  className="text-red-400 hover:text-red-300 transition-colors"
                >
                  Sign Out
                </button>
              </div>

              {isAdmin && (
                <>
                  {/* On Air Status */}
                  {isLive && (
                    <div className="bg-gradient-to-r from-red-600 to-red-800 border border-red-500 rounded-lg p-4 animate-pulse">
                      <div className="text-red-100 font-bold text-xl text-center">üéôÔ∏è ON AIR</div>
                      <div className="text-center text-red-200">
                        Time: {formatTime(onAirTime)}
                      </div>
                      {activeStreamers.length > 0 && (
                        <div className="mt-3 text-center">
                          <div className="text-red-200 text-sm">Active Streamers:</div>
                          {activeStreamers.map((streamer) => (
                            <div key={streamer.id} className="text-red-100 text-xs">
                              {streamer.email} - {streamer.type}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}

                   {/* Working Audio Controls */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-4 text-center">üéµ Audio Controls</h3>
                     
                     {/* Status Indicator */}
                     <div className="mb-4 p-3 bg-green-900 border border-green-600 rounded-lg">
                       <div className="text-green-200 text-sm text-center">
                         üéµ Audio System Active - Controls Working in Real-Time
                       </div>
                     </div>
                     
                     <div className="space-y-4">
                       {/* Main Volume Control */}
                       <div>
                         <label className="block text-sm font-medium text-gray-300 mb-2">
                           üîä Main Volume: {Math.round(volume * 100)}%
                         </label>
                         <input
                           type="range"
                           min="0"
                           max="1"
                           step="0.01"
                           value={volume}
                           onChange={handleVolumeChange}
                           className="w-full h-3 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                         />
                         <div className="text-center text-xs text-gray-400 mt-1">
                           {streamGainNode ? '‚úÖ Connected to Audio System' : '‚è≥ Connecting...'}
                         </div>
                       </div>

                       {/* Mic Volume Control */}
                       <div>
                         <label className="block text-sm font-medium text-gray-300 mb-2">
                           üé§ Mic Volume: {Math.round(micVolume * 100)}%
                         </label>
                         <input
                           type="range"
                           min="0"
                           max="1"
                           step="0.01"
                           value={micVolume}
                           onChange={handleMicVolumeChange}
                           className="w-full h-3 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                         />
                         <div className="text-center text-xs text-gray-400 mt-1">
                           {micGainNode ? '‚úÖ Connected to Audio System' : '‚è≥ Connecting...'}
                         </div>
                       </div>

                       {/* Crossfader Control */}
                       <div>
                         <label className="block text-sm font-medium text-gray-300 mb-2">
                           ‚ÜîÔ∏è Crossfader: {Math.round(crossfader * 100)}%
                         </label>
                         <div className="flex items-center space-x-4 mb-2">
                           <span className="text-sm text-blue-200 font-semibold">üéµ Stream</span>
                           <input
                             type="range"
                             min="0"
                             max="1"
                             step="0.01"
                             value={crossfader}
                             onChange={handleCrossfaderChange}
                             className="flex-1 h-3 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                           />
                           <span className="text-sm text-blue-200 font-semibold">üéµ Exclusive</span>
                         </div>
                         <div className="flex justify-between text-sm text-gray-300 mt-2">
                           <span className="bg-blue-600 px-2 py-1 rounded">Stream: {Math.round((1 - crossfader) * 100)}%</span>
                           <span className="bg-blue-600 px-2 py-1 rounded">Exclusive: {Math.round(crossfader * 100)}%</span>
                         </div>
                         <div className="text-center text-xs text-gray-400 mt-2">
                           {streamGainNode && exclusiveGainNode ? '‚úÖ Crossfader Active' : '‚è≥ Connecting...'}
                         </div>
                       </div>

                       {/* Individual Volume Controls */}
                       <div className="grid grid-cols-2 gap-4">
                         <div>
                           <label className="block text-sm font-medium text-gray-300 mb-2">
                             üéµ Stream Volume: {Math.round(streamVolume * 100)}%
                           </label>
                           <input
                             type="range"
                             min="0"
                             max="1"
                             step="0.01"
                             value={streamVolume}
                             onChange={handleStreamVolumeChange}
                             className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                           />
                         </div>
                         <div>
                           <label className="block text-sm font-medium text-gray-300 mb-2">
                             üéµ Exclusive Volume: {Math.round(exclusiveVolume * 100)}%
                           </label>
                           <input
                             type="range"
                             min="0"
                             max="1"
                             step="0.01"
                             value={exclusiveVolume}
                             onChange={handleExclusiveVolumeChange}
                             className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                           />
                         </div>
                       </div>
                     </div>
                   </div>

                   {/* MIDI Controller Support */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-4 text-center">üéπ MIDI Controller</h3>
                     <div className="space-y-4">
                       <div className="flex items-center justify-between">
                         <span className="text-gray-300">MIDI Status:</span>
                         <span className={`px-2 py-1 rounded text-xs font-semibold ${
                           midiConnected ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
                         }`}>
                           {midiConnected ? '‚úÖ Connected' : '‚ùå Disconnected'}
                         </span>
                       </div>
                       
                       {midiInputs.length > 0 && (
                         <div>
                           <label className="block text-sm font-medium text-gray-300 mb-2">
                             Select MIDI Input:
                           </label>
                           <select
                             value={selectedMidiInput?.id || ''}
                             onChange={(e) => {
                               const input = midiInputs.find(i => i.id === e.target.value);
                               if (input) connectMIDIInput(input);
                             }}
                             className="w-full bg-gray-700 text-white rounded px-3 py-2"
                           >
                             {midiInputs.map((input) => (
                               <option key={input.id} value={input.id}>
                                 {input.name || input.id}
                               </option>
                             ))}
                           </select>
                         </div>
                       )}
                       
                       <div className="text-xs text-gray-400">
                         <div>üéπ MIDI Controls:</div>
                         <div>CC7: Main Volume | CC8: Crossfader | CC9: Mic Volume</div>
                         <div>CC10: Stream Volume | CC11: Exclusive Volume</div>
                         <div>C2: Go Live Audio | C#2: Go Live Video | D2: Stop Live</div>
                         <div>D#2: Play Exclusive | E2: Start Podcast</div>
                       </div>
                     </div>
                   </div>

                   {/* Live Broadcasting Controls */}
                   <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                     <div className="bg-gray-800 rounded-lg p-4">
                       <h3 className="text-lg font-semibold text-white mb-3">üéôÔ∏è Live Audio</h3>
                       <button
                         onClick={isLive ? stopLive : goLiveAudio}
                         className={`w-full px-4 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 ${
                           isLive 
                             ? 'bg-red-600 hover:bg-red-700 text-white' 
                             : 'bg-green-600 hover:bg-green-700 text-white'
                         }`}
                       >
                         {isLive ? 'üõë Stop Live' : 'üéôÔ∏è Go Live Audio'}
                       </button>
                     </div>
                     
                     <div className="bg-gray-800 rounded-lg p-4">
                       <h3 className="text-lg font-semibold text-white mb-3">üìπ Live Video</h3>
                       <button
                         onClick={isVideoLive ? stopLive : goLiveVideo}
                         className={`w-full px-4 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 ${
                           isVideoLive 
                             ? 'bg-red-600 hover:bg-red-700 text-white' 
                             : 'bg-green-600 hover:bg-green-700 text-white'
                         }`}
                       >
                         {isVideoLive ? 'üõë Stop Live' : 'üìπ Go Live Video'}
                       </button>
                     </div>
                   </div>

                   {/* Exclusive Music Player */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-3">üéµ Play Exclusive</h3>
                     <div className="space-y-3">
                       <input
                         ref={fileInputRef}
                         type="file"
                         accept="audio/*"
                         onChange={handleFileSelect}
                         className="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700"
                       />
                       {exclusiveFile && (
                         <div className="bg-gray-700 rounded-lg p-3">
                           <div className="text-sm text-gray-300">File: <span className="text-white">{exclusiveFile.name}</span></div>
                           {isExclusivePlaying && (
                             <div className="mt-3 space-y-2">
                               <div className="text-sm text-gray-300">
                                 Duration: <span className="text-white">{formatTime(exclusiveElapsed)}</span> / <span className="text-white">{formatTime(exclusiveDuration)}</span>
                               </div>
                                                                <div className="w-full bg-gray-600 rounded-full h-2">
                                   <div 
                                     className="bg-blue-500 h-2 rounded-full transition-all duration-100"
                                     style={{ width: `${(exclusiveElapsed / exclusiveDuration) * 100}%` }}
                                   ></div>
                                 </div>
                               <div className="text-xs text-gray-400 text-center">
                                 {Math.round((exclusiveElapsed / exclusiveDuration) * 100)}% Complete
                               </div>
                             </div>
                           )}
                         </div>
                       )}
                       <button
                         onClick={startExclusiveFromFile}
                         disabled={!exclusiveFile}
                         className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white px-6 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 disabled:transform-none"
                       >
                         {isExclusivePlaying ? '‚è∏Ô∏è Stop' : '‚ñ∂Ô∏è Play Exclusive'}
                       </button>
                     </div>
                   </div>

                   {/* Podcast Recording */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-3">üéôÔ∏è Podcast Recording</h3>
                     <div className="space-y-3">
                       {isRecording && (
                         <div className="bg-gray-700 rounded-lg p-3 text-center">
                           <div className="text-red-400 font-semibold">Recording...</div>
                           <div className="text-2xl font-bold text-white">{formatTime(recordingTime)}</div>
                         </div>
                       )}
                       <div className="flex space-x-2">
                         <button
                           onClick={isRecording ? stopPodcast : startPodcast}
                           className={`flex-1 px-4 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 ${
                             isRecording 
                               ? 'bg-red-600 hover:bg-red-700 text-white' 
                               : 'bg-green-600 hover:bg-green-700 text-white'
                           }`}
                         >
                           {isRecording ? '‚èπÔ∏è Stop Recording' : 'üéôÔ∏è Start Recording'}
                         </button>
                       </div>
                     </div>
                   </div>

                   {/* Video Live Screen */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-3">üìπ Live Video Screen</h3>
                     <div id="video-live-screen" className="bg-gray-900 rounded-lg p-4 min-h-[300px] flex items-center justify-center">
                       {isVideoLive ? (
                         <div className="text-center">
                           <div className="text-green-400 text-2xl mb-2">üìπ</div>
                           <div className="text-white font-semibold">Live Video Streaming</div>
                           <div className="text-gray-400 text-sm">Your camera feed is live</div>
                         </div>
                       ) : (
                         <div className="text-center">
                           <div className="text-gray-500 text-4xl mb-2">üìπ</div>
                           <div className="text-gray-400 font-semibold">Video Screen</div>
                           <div className="text-gray-500 text-sm">Click &quot;Go Live Video&quot; to start</div>
                         </div>
                       )}
                     </div>
                   </div>

                   {/* Debug Panel */}
                   <div className="bg-gray-800 rounded-lg p-4">
                     <h3 className="text-lg font-semibold text-white mb-4">üîß Debug Panel</h3>
                     <div className="grid grid-cols-2 gap-4 text-xs text-gray-300">
                       <div>
                         <div>Audio Context: {audioContext ? '‚úÖ Active' : '‚ùå None'}</div>
                         <div>Mic Gain: {micGainNode ? '‚úÖ Active' : '‚ùå None'}</div>
                         <div>Stream Gain: {streamGainNode ? '‚úÖ Active' : '‚ùå None'}</div>
                         <div>Exclusive Gain: {exclusiveGainNode ? '‚úÖ Active' : '‚ùå None'}</div>
                       </div>
                       <div>
                         <div>Crossfader: {crossfader.toFixed(2)}</div>
                         <div>Mic Volume: {micVolume.toFixed(2)}</div>
                         <div>Stream Volume: {streamVolume.toFixed(2)}</div>
                         <div>Exclusive Volume: {exclusiveVolume.toFixed(2)}</div>
                       </div>
                     </div>
                     <div className="mt-4 space-y-2">
                       <button
                         onClick={testAudio}
                         className="w-full bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-xs font-semibold"
                       >
                         üß™ Test Basic Audio
                       </button>
                       <button
                         onClick={testAudioChain}
                         className="w-full bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-xs font-semibold"
                       >
                         üéµ Test Audio Chain
                       </button>
                       <button
                         onClick={testAudioSystem}
                         className="w-full bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-xs font-semibold"
                       >
                         üéß Test Audio System
                       </button>
                       <button
                         onClick={testWorkingAudio}
                         className="w-full bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-xs font-semibold"
                       >
                         üéµ Test Working Audio
                       </button>
                     </div>
                   </div>
                 </>
               )}

               {!isAdmin && (
                 <div className="text-center py-8">
                   <div className="text-gray-400 text-lg">
                     DJ Console controls are only available to admin users.
                   </div>
                 </div>
               )}
             </div>
           )}
         </div>

         <div className="bg-slate-800/80 backdrop-blur-sm rounded-lg p-6 shadow-lg border border-slate-600">
           <div className="text-center mb-6">
             <h2 className="text-2xl font-bold text-white mb-2">Radio Schedule</h2>
             <p className="text-slate-300">Your weekly Hip-Hop & R&B programming guide</p>
           </div>
           <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
             {schedule.map((slot, index) => (
               <div key={index} className="border border-slate-600 bg-slate-700 rounded-lg p-4">
                 <div className="font-semibold text-white">{slot.day}</div>
                 <div className="text-sm text-slate-300">{slot.time}</div>
                 <div className="text-blue-400 font-medium">{slot.show}</div>
                 <div className="mt-2">
                   <span className={`inline-block px-2 py-1 rounded text-xs font-semibold ${
                     slot.genre === 'Hip-Hop' ? 'bg-red-600 text-white' :
                     slot.genre === 'R&B' ? 'bg-blue-600 text-white' :
                     'bg-purple-600 text-white'
                   }`}>
                     {slot.genre}
                   </span>
                 </div>
               </div>
             ))}
           </div>
         </div>
       </div>
     </div>
   );
 }  // NOTE: All streams currently use the same URL for testing. Update with actual Hip-Hop & R&B streams.
